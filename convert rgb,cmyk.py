# -*- coding: utf-8 -*-
"""Copy of Kelompok 8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15zUHoOU27fZPUQY-Ll0eJ3t4HsxRePd7
"""

import cv2
import os
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import requests

from google.colab import drive
drive.mount('/content/drive')

# membuat folder
base_dir = '/content/drive/MyDrive/Colab/Pengolahan Citra'
pc_folder = os.path.join(base_dir, "Pengolahan Citra Berwarna")

if not os.path.exists(pc_folder):
  os.makedirs(pc_folder)

"""## **Helper Function**

### **load gambar dari url internet dan google drive**
"""

import cv2
import requests

def url_to_image(url):
    response = requests.get(url, stream=True).raw
    image = np.asarray(bytearray(response.read()), dtype="uint8")
    image = cv2.imdecode(image, cv2.IMREAD_COLOR)

    return image


def drive_to_image(img_id):
    url = fr"https://drive.google.com/uc?export=view&id={img_id}"
    response = requests.get(url, stream=True).raw
    image = np.asarray(bytearray(response.read()), dtype="uint8")
    image = cv2.imdecode(image, cv2.IMREAD_COLOR)

    return image

"""### **show image**"""

import cv2

def show_image(image, figsize=(12,12), color=cv2.COLOR_BGR2RGB, cmap=None):
    plt.figure(figsize=(12,12))
    plt.imshow(cv2.cvtColor(image, color), cmap=None), plt.xticks([]), plt.yticks([])

"""### **menampilkan full array tanpa trunkasi**


"""

import numpy as np

def show_full_array(array, limit=None):
    if(limit==None):
        limit = array.shape[1]*array.shape[0]

    count = 0
    for i in array:
        for j in i:
            if (type(j) == np.ndarray):
                print(j.tolist(),end=" ")
            else:
                print(j,end=" ")

            count += 1
            if (count == limit):
                break
        else:
            print("\n")
            continue
        break

import numpy as np
from prettytable import PrettyTable, MSWORD_FRIENDLY


def show_array_as_table(array, limit=None, start_row=None, end_row=None):
    if (limit==None):
        limit = array.shape[1]*array.shape[0]
  
    if (limit<array.shape[1]):
        header = [i for i in range(1,limit+1)]
    else:
        header = [i for i in range(1, array.shape[1]+1)]

    header.insert(0, "x/y")
    t = PrettyTable(header)
    t.set_style(MSWORD_FRIENDLY)
  
    first = 1

    if (start_row == None):
        start_row = 0
        first = start_row + 1
    else:
        first = start_row

    if (end_row == None):
        end_row = len(array)
    
  

    count = 0
  
    for no_row, row in enumerate(array[start_row:end_row], start=first):
        rows = [no_row]
        for col in row:
            if (count >= limit):
                break
            if (type(col) == np.ndarray):
                col = col.tolist()
                rows.append(col)
            else:
                rows.append(col)


            count += 1

        if(len(rows)!=1):
            if(len(rows)!=len(header)):
                for i in range(len(header)-len(rows)):
                    rows.append(" ")
            
            t.add_row(rows)

    return t

"""## **Load gambar**"""

img = url_to_image("https://www.w3schools.com/w3css/img_lights.jpg")

cv2.imwrite(os.path.join(pc_folder, "img_original_rgb.jpg"), img)
show_image(img)

img[:,:,::-1]

"""## **RGB to CMYK**

$R' = R/255$\
$G' = G/255$\
$B' = B/255$

$K = 1-max(R', G', B')$\
$C = (1-R'-K) / (1-K)$\
$M = (1-G'-K) / (1-K)$\
$Y = (1-B'-K) / (1-K)$

source algoritma: https://www.rapidtables.com/convert/color/rgb-to-cmyk.html
"""

import numpy as np

def RGB2CMYK(img):  
    BGR = img.copy().astype(float)/255

    K = 1 - np.max(BGR, axis=2)
    C = (1 - BGR[...,2] - K)/((1-K)+0.000000000001) #menambahkan angka kecil ke penyebut agar tidak terjadi pembagian dengan 0
    M = (1 - BGR[...,1] - K)/((1-K)+0.000000000001)
    Y = (1 - BGR[...,0] - K)/((1-K)+0.000000000001)
  
    CMYK = (np.dstack((C,M,Y,K)) * 255).astype(np.uint8)

    return CMYK

CMYK = RGB2CMYK(img)

CMYK

from PIL import Image

cmyk_img = Image.fromarray(CMYK, mode="CMYK")
cmyk_img.save(os.path.join(pc_folder, "img_rgb2cmyk.jpg"))

from IPython.display import Image as display_image
display_image(filename=os.path.join(pc_folder, "img_rgb2cmyk.jpg"))



"""## **CMYK to RGB**

$R = 255 √ó (1-C) √ó (1-K)$\
$G = 255 √ó (1-M) √ó (1-K)$\
$B = 255 √ó (1-Y) √ó (1-K)$

source algoritma: https://www.rapidtables.com/convert/color/cmyk-to-rgb.html
"""

def CMYK2RGB(img):
    C = img[:,:,0].astype(float)/255
    M = img[:,:,1].astype(float)/255
    Y = img[:,:,2].astype(float)/255
    K = img[:,:,3].astype(float)/255

    R = 255 * (1-C) * (1-K)
    G = 255 * (1-M) * (1-K)
    B = 255 * (1-Y) * (1-K)

    RGB = np.dstack((R,G,B)).astype(np.uint8)

    return RGB

rgb_cmyk = CMYK2RGB(CMYK)

rgb_cmyk

from PIL import Image

cmyk2rgb_img = Image.fromarray(rgb_cmyk, mode="RGB")
cmyk2rgb_img.save(os.path.join(pc_folder, "img_cmyk2rgb.jpg"))

from IPython.display import Image as display_image
display_image(filename=os.path.join(pc_folder, "img_cmyk2rgb.jpg"))



"""## **RGB to YIQ**

$\begin{bmatrix}Y \\ I \\ Q\end{bmatrix}=\begin{bmatrix}0.299 & 0.587 & 0.114\\0.596 & -0.274 & -0.322\\0.211 & -0.523 & 0.312\\\end{bmatrix}\begin{bmatrix}R \\ G \\ B \end{bmatrix}$

source algoritma: https://stackoverflow.com/questions/46990838/numpy-transforming-rgb-image-to-yiq-color-space
"""

import numpy as np

def RGB2YIQ(img):
    BGR = img.copy().astype(float)
    R = BGR[:,:,2]
    G = BGR[:,:,1]
    B = BGR[:,:,0]

    Y = (0.299 * R) + (0.587 * G) + (0.114 * B)
    I = (0.59590059 * R) + (-0.27455667 * G) + (-0.32134392 * B)
    Q = (0.21153661 * R) + (-0.52273617 * G) + (0.31119955 * B)

    YIQ = (np.dstack((Y,I + 128,Q + 128))).astype(np.uint8)

    return YIQ

YIQ = RGB2YIQ(img)

YIQ

from PIL import Image

yiq_img = Image.fromarray(YIQ, mode="YCbCr")
yiq_img.save(os.path.join(pc_folder, "img_rgb2yiq.jpg"))

from IPython.display import Image as display_image
display_image(filename=os.path.join(pc_folder, "img_rgb2yiq.jpg"))



"""## **YIQ to RGB**

$\begin{bmatrix}R \\ G \\ B\end{bmatrix}=\begin{bmatrix}1 & 0.956 & 0.621\\1 & -0.272 & -0.647\\1 & -1.106 & 1.703\\\end{bmatrix}\begin{bmatrix}Y \\ I \\ Q \end{bmatrix}$

source algoritma: pdf elena
"""

import numpy as np

np.linalg.inv(np.array([[0.299,0.587,0.114],
                        [0.59590059,-0.27455667,-0.32134392],
                        [0.21153661,-0.52273617,0.31119955]]))

import numpy as np

def YIQ2RGB(img):
    YIQ = img.copy().astype(int)
    Y = YIQ[:,:,0]
    I = YIQ[:,:,1] - 128
    Q = YIQ[:,:,2] - 128

    R = (1 * Y) + (0.95598634 * I) + (0.6208248 * Q)
    G = (1 * Y) + (-0.27201283 * I) + (-0.64720424 * Q)
    B = (1 * Y) + (-1.10674021 * I) + (1.70423049 * Q)

    RGB = np.clip(np.dstack((R,G,B)),0,255).astype(np.uint8)

    return RGB

rgb_yiq = YIQ2RGB(YIQ)

rgb_yiq

rgb_yiq_img = Image.fromarray(rgb_yiq, mode="RGB")
rgb_yiq_img.save(os.path.join(pc_folder, "img_yiq2rgb.jpg"))

rgb_yiq_img



"""## **RGB ke YCbCr**

$ùëå = 0.29900ùëÖ + 0.58700ùê∫ + 0.11400ùêµ$\
$ùê∂ùëè = ‚àí0.16874ùëÖ ‚àí 0.33126ùê∫ + 0.5000ùêµ$\
$ùê∂ùëü = 0.5000ùëÖ ‚àí 0.41869ùê∫ ‚àí 0.08131ùêµ$

source algoritma: pdf elena
"""

import numpy as np

def RGB2YCB(img):
    BGR = img.copy().astype(float)
    R = BGR[:,:,2]
    G = BGR[:,:,1]
    B = BGR[:,:,0]

    Y = (0.299 * R) + (0.587 * G) + (0.114 * B)
    Cb = ((-0.16874 * R) + (-0.33126 * G) + (0.5 * B)+128)
    Cr = ((0.5 * R) + (-0.41869 * G) + (-0.08131 * B)+128)

    YCbCr = (np.dstack((Y,Cb,Cr))).astype(np.uint8)

    return YCbCr

YCB = RGB2YCB(img)

YCB

ycb_img = Image.fromarray(YCB, mode="YCbCr")
ycb_img.save(os.path.join(pc_folder, "img_rgb2ycb.jpg"))

from IPython.display import Image as display_image
display_image(filename=os.path.join(pc_folder, "img_rgb2ycb.jpg"))



"""## **YCbCr to RGB**

$ùëÖ = ùëå + 1.40200ùê∂ùëü$\
$ùê∫ = ùëå ‚àí 0,34414ùê∂ùëè ‚àí 0,71414ùê∂ùëü$\
$ùêµ = ùëå + 1,77200ùê∂ùëè$


source algoritma: pdf elena
"""

import numpy as np

np.set_printoptions(suppress=True)
np.linalg.inv(np.array([[0.299,0.587,0.114],
                        [-0.16874,-0.33126,0.5],
                        [0.5,-0.41869,-0.08131]]))

import numpy as np

def YCB2RGB(img):
    YCbCr = img.copy().astype(int)
    Y = YCbCr[:,:,0]
    Cb = YCbCr[:,:,1] - 128
    Cr = YCbCr[:,:,2] - 128

    R = (1 * Y) + (-0.00000715 * Cb) + (1.40199759 * Cr)
    G = (1 * Y) + (-0.34413313 * Cb) + (-0.71413805 * Cr)
    B = (1 * Y) + (1.77200251 * Cb) + (0.00001541 * Cr)

    RGB = (np.dstack((R,G,B)))

    return np.absolute(RGB).astype(np.uint8)

rgb_ycb = YCB2RGB(YCB)

rgb_ycb

rgb_ycb_img = Image.fromarray(rgb_ycb, mode="RGB")
rgb_ycb_img.save(os.path.join(pc_folder, "img_ycb2rgb.jpg"))
rgb_ycb_img



"""## **RGB to HSV**

$R' = R/255$\
$G' = G/255$\
$B' = B/255$

$Cmax = max(R', G', B')$\
$Cmin = min(R', G', B')$

$Œî = Cmax - Cmin$

\
Menghitung H:\
$H=\left \{ \begin{matrix}0^{\circ} & ,\Delta = 0\\60^{\circ}\times \left (\frac{G'-B'}{\Delta}mod6\right)&, Cmax = R'\\60^{\circ}\times \left (\frac{B'-R'}{\Delta}+2\right)&, Cmax = G'\\60^{\circ}\times \left (\frac{R'-G'}{\Delta}+4\right)&, Cmax = B'\\\end{matrix} \right \}$

\
Menghitung S:\
$S=\left \{ \begin{matrix}0&,Cmax=0\\\frac{\Delta}{Cmax}&,Cmax \neq 0\\\end{matrix} \right \}$

\
Menghitung V:\
$V = Cmax$

source algoritma: https://www.rapidtables.com/convert/color/rgb-to-hsv.html
"""

import numpy as np

def find_H_RGB2HSV(delta, Cmax, r, g, b):
    if delta==0:
        return 0
    elif Cmax == r:
        H = round(60 * (((g - b)/delta)%6))
        return H
    elif Cmax == g:
        H = round(60 * (((b - r)/delta)+2))
        return H
    elif Cmax == b:
        H = round(60 * (((r - g)/delta)+4))
        return H

vfind_H_RGB2HSV = np.vectorize(find_H_RGB2HSV, otypes=[np.int])

def find_S_RGB2HSV(Cmax, delta):
    if Cmax != 0:
        S = delta/Cmax
        return S
    elif Cmax==0:
        return 0 

vfind_S_RGB2HSV = np.vectorize(find_S_RGB2HSV)

def RGB2HSV(img):
    rgb = img[:,:,::-1].copy()
    r = rgb[:,:,0]/255
    g = rgb[:,:,1]/255
    b = rgb[:,:,2]/255

    Cmax = np.max(rgb/255, axis=2)
    Cmin = np.min(rgb/255, axis=2)
    delta = Cmax - Cmin

    H = vfind_H_RGB2HSV(delta, Cmax, r, g, b)
    S = vfind_S_RGB2HSV(Cmax, delta) *100
    V = (Cmax * 100)

    HSV = np.dstack(((H/360 * 255),(S/100*255),(V/100*255))).astype(np.uint8)

    return HSV

HSV = RGB2HSV(img)

HSV

hsv_img = Image.fromarray(HSV, mode="RGB")
hsv_img.save(os.path.join(pc_folder, "img_rgb2hsv.jpg"))

from IPython.display import Image as display_image
display_image(filename=os.path.join(pc_folder, "img_rgb2hsv.jpg"))



"""## **HSV to RGB**

0 ‚â§ H < 360, 0 ‚â§ S ‚â§ 1 and 0 ‚â§ V ‚â§ 1:

$C = V √ó S$\
$X = C √ó (1 - |(\frac{H}{60^{\circ}}) mod 2 - 1|)$\
$m = V - C$

\
$(R',G',B') =\begin{Bmatrix}(C,X,0) & ,0^{\circ}\leq H < 60^{\circ}\\(X,C,0) & ,60^{\circ}\leq H < 120^{\circ}\\(0,C,X) & ,120^{\circ}\leq H < 180^{\circ}\\(0,X,C) & ,180^{\circ}\leq H < 240^{\circ}\\(X,0,C) & ,240^{\circ}\leq H < 300^{\circ}\\(C,0,X) & ,300^{\circ}\leq H < 360^{\circ}\end{Bmatrix}$

\
$(R,G,B) = ((R'+m)√ó255, (G'+m)√ó255, (B'+m)√ó255)$

source algoritma: https://www.rapidtables.com/convert/color/hsv-to-rgb.html
"""

import numpy as np

def r_prime_HSV2RGB(H,C,X, zero):
    if 0 <= H < 60:
        return C
    elif 60 <= H < 120:
        return X
    elif 120 <= H < 180:
        return zero
    elif 180 <= H < 240:
        return zero
    elif 240 <= H < 300:
        return X
    elif 300 <= H <= 360:
        return C

def g_prime_HSV2RGB(H,C,X, zero):
    if 0 <= H < 60:
        return X
    elif 60 <= H < 120:
        return C
    elif 120 <= H < 180:
        return C
    elif 180 <= H < 240:
        return X
    elif 240 <= H < 300:
        return zero
    elif 300 <= H <= 360:
        return zero

def b_prime_HSV2RGB(H,C,X,zero):
    if 0 <= H < 60:
        return zero
    elif 60 <= H < 120:
        return zero
    elif 120 <= H < 180:
        return X
    elif 180 <= H < 240:
        return C
    elif 240 <= H < 300:
        return C
    elif 300 <= H <= 360:
        return X

vr_prime_HSV2RGB = np.vectorize(r_prime_HSV2RGB)
vg_prime_HSV2RGB = np.vectorize(g_prime_HSV2RGB)
vb_prime_HSV2RGB = np.vectorize(b_prime_HSV2RGB)

def HSV2RGB(img):
    HSV = img.copy()
    H = np.around(img[:,:,0]/255*360)
    S = img[:,:,1]/255
    V = img[:,:,2]/255
    
    C = V * S
    X = C * (1-np.absolute(((H/60)%2)-1))
    m = V-C

    zero = np.zeros_like(H)
    r = vr_prime_HSV2RGB(H,C,X,zero)
    g = vg_prime_HSV2RGB(H,C,X,zero)
    b = vb_prime_HSV2RGB(H,C,X,zero)

    R = (r+m)*255
    G = (g+m)*255
    B = (b+m)*255

    RGB = np.dstack((R,G,B)).astype(np.uint8)

    return RGB

rgb_hsv = HSV2RGB(HSV)

rgb_hsv

rgb_hsv_img = Image.fromarray(rgb_hsv, mode="RGB")
rgb_hsv_img.save(os.path.join(pc_folder, "img_hsv2rgb.jpg"))
rgb_hsv_img



"""## **RGB to HSI**

$R' = R/255$\
$G' = G/255$\
$B' = B/255$

$\theta = \cos^{-1}\left ( \frac{\frac{1}{2}\left [ \left ( R'-G' \right ) + \left ( R'-B' \right )\right ]}{\left [ \left (R'-G'  \right )^{2}+\left ( R'-B' \right )\left ( G'-B' \right )\right ]^{\frac{1}{2}}} \right )$

\
$H = \left \{ \begin{matrix}\theta  & , B'\leq G' \\ 360 - \theta& ,B'>G'\end{matrix} \right \}$

\
$S=1-\frac{3}{\left ( R'+G'+B' \right )}\left [ \min(R',G',B') \right ]$

\
$I=\frac{1}{3}\left ( R'+G'+B' \right )$

source algoritma: https://www.imageeprocessing.com/2013/05/converting-rgb-image-to-hsi.html
"""

def find_H_RGB2HSI(theta, b, g):
    if b <= g:
        return theta
    else:
        return 360-theta

vfind_H_RGB2HSI = np.vectorize(find_H_RGB2HSI)

def RGB2HSI(img):
    rgb = img[:,:,::-1].copy()
    r = rgb[:,:,0]/255
    g = rgb[:,:,1]/255
    b = rgb[:,:,2]/255

    numerator = 0.5*((r-g)+(r-b))
    denominator = (((r-g)**2)+((r-b)*(g-b)))**0.5
    theta = np.arccos(numerator/(denominator+0.000000000001))*180/np.pi

    H = vfind_H_RGB2HSI(theta, b, g)
    S = 1-3*np.min(rgb/255, axis=2)/((r+g+b)+0.000000000001)
    I = (r+g+b)/3

    HSI = np.dstack(((H/360)*255,S*255,I*255)).astype(np.uint8)

    return HSI

HSI = RGB2HSI(img)

HSI

hsi_img = Image.fromarray(HSI, mode="RGB")
hsi_img.save(os.path.join(pc_folder, "img_rgb2hsi.jpg"))

from IPython.display import Image as display_image
display_image(filename=os.path.join(pc_folder, "img_rgb2hsi.jpg"))



"""## **HSI to RGB**

$if (0^{\circ}\leq H < 120^{\circ}):$\
\
$B=I(1-S)$\
$R = I\left ( 1 + \frac{S \cos H}{\cos (60^{\circ} -H)} \right )$\
$G = 3 \times I - (R + B)$


---
$if (120^{\circ}\leq H < 240^{\circ}):$\
\
$H = H ‚àí 120 $\
$R = I(1-S)$\
$G = I\left ( 1 + \frac{S \cos H}{\cos (60^{\circ} -H)} \right )$\
$B = 3 \times I - (R + G)$

---

$if (240^{\circ}\leq H \leq 360^{\circ}):$\
\
$H = H ‚àí 240 $\
$G = I(1-S)$\
$B = I\left ( 1 + \frac{S \cos H}{\cos (60^{\circ} -H)} \right )$\
$R = 3 \times I - (G + B)$

source algoritma: https://www.imageeprocessing.com/2013/06/convert-hsi-image-to-rgb-image.html
"""

def find_RGB_HSI2RGB(H,S,I,channel):
    if 0 <= H < 120:
        B = I * (1 - S)
        R = I * (1 + ((S*np.cos(np.deg2rad(H)))/((np.cos(np.deg2rad(60 - H))+0.000000000001))))
        G = 3*I - (R + B)
    elif 120 <= H < 240:
        H = H - 120
        R = I * (1 - S)
        G = I * (1 + ((S*np.cos(np.deg2rad(H)))/((np.cos(np.deg2rad(60 - H))+0.000000000001))))
        B = 3*I - (R + G)
    elif 240 <= H <= 360:
        H = H - 240
        G = I * (1 - S)
        B = I * (1 + ((S*np.cos(np.deg2rad(H)))/((np.cos(np.deg2rad(60 - H))+0.000000000001))))
        R = 3*I - (G + B)

    if channel == "R":
        return R
    elif channel == "G":
        return G
    elif channel == "B":
        return B

vfind_RGB_HSI2RGB = np.vectorize(find_RGB_HSI2RGB)

def HSI2RGB(img):
    HSI = img.copy()
    H = np.around((HSI[:,:,0]/255)*360)
    S = HSI[:,:,1]/255
    I = HSI[:,:,2]/255

    R = vfind_RGB_HSI2RGB(H,S,I,"R")
    G = vfind_RGB_HSI2RGB(H,S,I,"G")
    B = vfind_RGB_HSI2RGB(H,S,I,"B")

    RGB = (np.dstack((R,G,B))*255).astype(np.uint8)

    return RGB

rgb_hsi = HSI2RGB(HSI)

rgb_hsi

rgb_hsi_img = Image.fromarray(rgb_hsi, mode="RGB")
rgb_hsi_img.save(os.path.join(pc_folder, "img_hsi2rgb.jpg"))
rgb_hsi_img



"""## **RGB to HSL**

$R' = R/255$\
$G' = G/255$\
$B' = B/255$

$Cmax = max(R', G', B')$\
$Cmin = min(R', G', B')$

$Œî = Cmax - Cmin$

\
Menghitung H:\
$H=\left \{ \begin{matrix}0^{\circ} & ,\Delta = 0\\60^{\circ}\times \left (\frac{G'-B'}{\Delta}mod6\right)&, Cmax = R'\\60^{\circ}\times \left (\frac{B'-R'}{\Delta}+2\right)&, Cmax = G'\\60^{\circ}\times \left (\frac{R'-G'}{\Delta}+4\right)&, Cmax = B'\\\end{matrix} \right \}$

\
Menghitung S:\
$S=\left \{ \begin{matrix}0&,Cmax=0\\\frac{\Delta}{1-|2L-1|}&,Cmax \neq 0\\\end{matrix} \right \}$

\
Menghitung L:\
$L = (Cmax + Cmin) / 2$

source algoritma: https://www.rapidtables.com/convert/color/rgb-to-hsl.html
"""

def find_H_RGB2HSL(delta, Cmax, r, g, b):
    if delta==0:
        return 0
    elif Cmax == r:
        H = round(60 * (((g - b)/delta)%6))
        return H
    elif Cmax == g:
        H = round(60 * (((b - r)/delta)+2))
        return H
    elif Cmax == b:
        H = round(60 * (((r - g)/delta)+4))
        return H

vfind_H_RGB2HSL = np.vectorize(find_H_RGB2HSL, otypes=[np.int])

def find_S_RGB2HSL(Cmax, delta, L):
    if Cmax != 0:
        S = delta/(1-np.absolute(2*L-1)+0.000000000001)
        return S
    elif Cmax==0:
        return 0 

vfind_S_RGB2HSL = np.vectorize(find_S_RGB2HSL)

def RGB2HSL(img):
    rgb = img[:,:,::-1].copy()

    r = rgb[:,:,0]/255
    g = rgb[:,:,1]/255
    b = rgb[:,:,2]/255

    Cmax = np.max(rgb/255, axis=2)
    Cmin = np.min(rgb/255, axis=2)

    delta = Cmax - Cmin

    L = (Cmax + Cmin)/2
    H = vfind_H_RGB2HSL(delta, Cmax, r, g, b)
    S = vfind_S_RGB2HSL(Cmax, delta, L)

    HSL = np.dstack(((H/360)*255,S*255,L*255)).astype(np.uint8)
    
    return HSL

HSL = RGB2HSL(img)

HSL

hsl_img = Image.fromarray(HSL, mode="RGB")
hsl_img.save(os.path.join(pc_folder, "img_rgb2hsl.jpg"))

from IPython.display import Image as display_image
display_image(filename=os.path.join(pc_folder, "img_rgb2hsl.jpg"))



"""## **HSL to RGB**

0 ‚â§ H < 360, 0 ‚â§ S ‚â§ 1 and 0 ‚â§ V ‚â§ 1:

$C = (1 - |2L - 1|) √ó S$\
$X = C √ó (1 - |(\frac{H}{60^{\circ}}) mod 2 - 1|)$\
$m = L - C/2$

\
$(R',G',B') =\begin{Bmatrix}(C,X,0) & ,0^{\circ}\leq H < 60^{\circ}\\(X,C,0) & ,60^{\circ}\leq H < 120^{\circ}\\(0,C,X) & ,120^{\circ}\leq H < 180^{\circ}\\(0,X,C) & ,180^{\circ}\leq H < 240^{\circ}\\(X,0,C) & ,240^{\circ}\leq H < 300^{\circ}\\(C,0,X) & ,300^{\circ}\leq H < 360^{\circ}\end{Bmatrix}$

\
$(R,G,B) = ((R'+m)√ó255, (G'+m)√ó255, (B'+m)√ó255)$

source algoritma: https://www.rapidtables.com/convert/color/hsl-to-rgb.html
"""

import numpy as np

def r_prime_HSL2RGB(H,C,X, zero):
    if 0 <= H < 60:
        return C
    elif 60 <= H < 120:
        return X
    elif 120 <= H < 180:
        return zero
    elif 180 <= H < 240:
        return zero
    elif 240 <= H < 300:
        return X
    elif 300 <= H <= 360:
        return C

def g_prime_HSL2RGB(H,C,X, zero):
    if 0 <= H < 60:
        return X
    elif 60 <= H < 120:
        return C
    elif 120 <= H < 180:
        return C
    elif 180 <= H < 240:
        return X
    elif 240 <= H < 300:
        return zero
    elif 300 <= H <= 360:
        return zero

def b_prime_HSL2RGB(H,C,X,zero):
    if 0 <= H < 60:
        return zero
    elif 60 <= H < 120:
        return zero
    elif 120 <= H < 180:
        return X
    elif 180 <= H < 240:
        return C
    elif 240 <= H < 300:
        return C
    elif 300 <= H <= 360:
        return X

vr_prime_HSL2RGB = np.vectorize(r_prime_HSL2RGB)
vg_prime_HSL2RGB = np.vectorize(g_prime_HSL2RGB)
vb_prime_HSL2RGB = np.vectorize(b_prime_HSL2RGB)

def HSL2RGB(img):
    HSL = img.copy()
    H = np.around(img[:,:,0]/255*360)
    S = img[:,:,1]/255
    L = img[:,:,2]/255
    
    C = (1-np.absolute(2*L-1))*S
    X = C * (1-np.absolute(((H/60)%2)-1))
    m = L-(C/2)

    zero = np.zeros_like(H)
    r = vr_prime_HSL2RGB(H,C,X,zero)
    g = vg_prime_HSL2RGB(H,C,X,zero)
    b = vb_prime_HSL2RGB(H,C,X,zero)

    R = (r+m)*255
    G = (g+m)*255
    B = (b+m)*255

    RGB = np.dstack((R,G,B)).astype(np.uint8)

    return RGB

rgb_hsl = HSL2RGB(HSL)

rgb_hsl

rgb_hsl_img = Image.fromarray(rgb_hsl, mode="RGB")
rgb_hsl_img.save(os.path.join(pc_folder, "img_hsl2rgb.jpg"))
rgb_hsl_img



"""## **RGB to CIELAB**

$R' = R/255$\
$G' = G/255$\
$B' = B/255$

\
$R' = \left \{ \begin{matrix}\left (\frac{ R' + 0.055}{ 1.055}  \right )^{2.4} & ,R' > 0.04045\\\frac{R'}{12.92} & ,R' \leq  0.04045\end{matrix} \right \}$

\
$G' = \left \{ \begin{matrix}\left (\frac{ G' + 0.055}{ 1.055}  \right )^{2.4} & ,G' > 0.04045\\\frac{G'}{12.92} & ,G' \leq  0.04045\end{matrix} \right \}$

\
$B' = \left \{ \begin{matrix}\left (\frac{ B' + 0.055}{ 1.055}  \right )^{2.4} & ,B' > 0.04045\\\frac{B'}{12.92} & ,B' \leq  0.04045\end{matrix} \right \}$

\
$R' = R' \times 100$\
$G' = G' \times 100$\
$B' = B' \times 100$

\
$X = R' \times 0.4124 + G' \times 0.3576 + B' \times 0.1805$\
$Y = R' \times 0.2126 + G' \times 0.7152 + B' \times 0.0722$\
$Z = R' \times 0.0193 + G' \times 0.1192 + B' \times 0.9505$

\
$X' = X / 95.047$\
$Y' = Y / 100$\
$Z' = Z / 108.883$

\
$X' = \left \{ \begin{matrix}X'^{(\frac{1}{3})} & ,X' > 0.008856\\ ( 7.787 \times X' ) + ( \frac{16}{116} ) & ,X' > 0.008856\end{matrix} \right \}$

\
$Y' = \left \{ \begin{matrix}
Y'^{(\frac{1}{3})} & ,Y' > 0.008856\\ 
( 7.787 \times Y' ) + ( \frac{16}{116} ) & ,Y' > 0.008856
\end{matrix} \right \}$

\
$Z' = \left \{ \begin{matrix}
Z'^{(\frac{1}{3})} & ,Z' > 0.008856\\ 
( 7.787 \times Z' ) + ( \frac{16}{116} ) & ,Z' > 0.008856
\end{matrix} \right \}$

\
$L^{*} = ( 116 \times Y' ) - 16$\
$a^{*} = 500 \times ( X' - Y' )$\
$b^{*} = 200 \times ( Y' - Z' )$

source algoritma: 
- http://www.easyrgb.com/en/math.php, 
- https://gist.github.com/manojpandey/f5ece715132c572c80421febebaf66ae
"""

def prep_rgb_RGB2LAB(rgb):
    if (rgb > 0.04045 ):
        rgb = ( ( rgb + 0.055 ) / 1.055 ) ** 2.4

        return rgb *100
    else:
        rgb = rgb / 12.92

        return rgb*100

vprep_rgb_RGB2LAB = np.vectorize(prep_rgb_RGB2LAB)

def prep_XYZ_RGB2LAB(var_XYZ):
    if ( var_XYZ > 0.008856 ):
        return var_XYZ**( 1/3 )
    else:                   
        return ( 7.787 * var_XYZ ) + ( 16 / 116 )

vprep_XYZ_RGB2LAB = np.vectorize(prep_XYZ_RGB2LAB)

def RGB2LAB(img):
    rgb = img[:,:,::-1].copy()
    r = rgb[:,:,0]/255
    g = rgb[:,:,1]/255
    b = rgb[:,:,2]/255

    r = vprep_rgb_RGB2LAB(r)
    g = vprep_rgb_RGB2LAB(g)
    b = vprep_rgb_RGB2LAB(b)

    X = (r * 0.4124) + (g * 0.3576) + (b * 0.1805)
    Y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722)
    Z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505)

    var_X = X / 95.047
    var_Y = Y / 100.0
    var_Z = Z / 108.883

    var_X = vprep_XYZ_RGB2LAB(var_X)
    var_Y = vprep_XYZ_RGB2LAB(var_Y)
    var_Z = vprep_XYZ_RGB2LAB(var_Z)

    L = ( 116 * var_Y ) - 16
    a = 500 * ( var_X - var_Y )
    b = 200 * ( var_Y - var_Z )

    Lab = np.around(np.dstack((L/100*255,a+128,b+128))).astype(np.uint8)

    return Lab

LAB = RGB2LAB(img)

LAB

lab_img = Image.fromarray(LAB, mode="RGB")
lab_img.save(os.path.join(pc_folder, "img_rgb2lab.jpg"))

from IPython.display import Image as display_image
display_image(filename=os.path.join(pc_folder, "img_rgb2lab.jpg"))



"""## **CIELAB to RGB**

$Y' = \frac{(L^{*} + 16 )}{116}$\
$X' = \frac{a^{*}}{500} + Y'$\
$Z' = Y' - b^{*} / 200$

\
$X' = \left \{ \begin{matrix}
X'^{(3)} & ,X'^{(3)}  > 0.008856\\ 
\frac{X' - \frac{16}{116}}{7.787}& ,X'^{(3)}  \leq  0.008856
\end{matrix} \right \}$

\
$Y' = \left \{ \begin{matrix}
Y'^{(3)} & ,Y'^{(3)}  > 0.008856\\ 
\frac{Y' - \frac{16}{116}}{7.787}& ,Y'^{(3)}  \leq  0.008856
\end{matrix} \right \}$

\
$Z' = \left \{ \begin{matrix}
Z'^{(3)} & ,Z'^{(3)}  > 0.008856\\ 
\frac{Z' - \frac{16}{116}}{7.787}& ,Z'^{(3)}  \leq  0.008856
\end{matrix} \right \}$

\
$X = X' \times \frac{95.047}{100}$\
$Y = Y' $\
$Z = Z' \times \frac{108.883}{100}$

\
$R' = X \times  3.2406 + Y \times -1.5372 + Z \times -0.4986\\
G' = X \times -0.9689 + Y \times  1.8758 + Z \times  0.0415\\
B' = X \times  0.0557 + Y \times -0.2040 + Z \times  1.0570$

\
$R' = \left \{
\begin{matrix}
 1.055 \times R'^{(\frac{1}{2.4})} - 0.055& ,R' > 0.0031308\\ 
 12.92 \times R'& ,R' \leq 0.0031308
\end{matrix}
\right \}$

\
$G' = \left \{
\begin{matrix}
 1.055 \times G'^{(\frac{1}{2.4})} - 0.055& ,G' > 0.0031308\\ 
 12.92 \times G'& ,G' \leq 0.0031308
\end{matrix}
\right \}$

\
$B' = \left \{
\begin{matrix}
 1.055 \times B'^{(\frac{1}{2.4})} - 0.055& ,B' > 0.0031308\\ 
 12.92 \times B'& ,B' \leq 0.0031308
\end{matrix}
\right \}$

\
$R = R' \times 255\\
G = G' \times 255\\
B = B' \times 255$

source algoritma: http://www.easyrgb.com/en/math.php
"""

def prep_XYZ_LAB2RGB(var_XYZ):
    if ( var_XYZ**3  > 0.008856 ):
        return var_XYZ**3
    else:
        return ( var_XYZ - 16 / 116 ) / 7.787

vprep_XYZ_LAB2RGB = np.vectorize(prep_XYZ_LAB2RGB)

def prep_RGB_LAB2RGB(var_RGB):
    if ( var_RGB > 0.0031308 ):
        return 1.055 * ( var_RGB ** ( 1 / 2.4 ) ) - 0.055
    else:
        return 12.92 * var_RGB

vprep_RGB_LAB2RGB = np.vectorize(prep_RGB_LAB2RGB)

def LAB2RGB(img):
    Lab = img.copy()

    L = (Lab[:,:,0]/255*100).astype(int)
    a = Lab[:,:,1].astype(float) - 128
    b = Lab[:,:,2].astype(float) - 128

    var_Y = ( L + 16 ) / 116
    var_X = a/ 500 + var_Y
    var_Z = var_Y - b / 200

    var_Y_ = vprep_XYZ_LAB2RGB(var_Y)
    var_X_ = vprep_XYZ_LAB2RGB(var_X)
    var_Z_ = vprep_XYZ_LAB2RGB(var_Z)

    X = (var_X_ * 95.047)/100
    Y = (var_Y_ * 100.0 )/100
    Z = (var_Z_ * 108.883)/100

    r = (X *  3.240479) + (Y * -1.537150) + (Z * -0.498535)
    g = (X * -0.969256) + (Y *  1.875992) + (Z * 0.041556)
    b = (X *  0.055648) + (Y * -0.204043) + (Z *  1.057311)

    R = np.around(np.clip(vprep_RGB_LAB2RGB(r)* 255, 0, 255))
    G = np.around(np.clip(vprep_RGB_LAB2RGB(g)* 255, 0, 255))
    B = np.around(np.clip(vprep_RGB_LAB2RGB(b)* 255, 0, 255))

    RGB = np.dstack((R,G,B)).astype(np.uint8)

    return RGB

rgb_lab = LAB2RGB(LAB)

rgb_lab

rgb_lab_img = Image.fromarray(rgb_lab, mode="RGB")
rgb_lab_img.save(os.path.join(pc_folder, "img_lab2rgb.jpg"))
rgb_lab_img



"""## **Statistika Warna**

$\mu = \frac{\sum_{i=1}^{M}\sum_{i=1}^{N} P_{ij}}{MN}$

\
$\sigma = \sqrt{\frac{\sum_{i=1}^{M}\sum_{i=1}^{N} \left (P_{ij}-\mu   \right )^{2}}{MN}}$

\
$\theta = \frac{\sum_{i=1}^{M}\sum_{i=1}^{N} \left (P_{ij}-\mu   \right )^{3}}{MN\sigma^{3} }$

\
$\gamma = \frac{\sum_{i=1}^{M}\sum_{i=1}^{N} \left (P_{ij}-\mu   \right )^{4}}{MN\sigma^{4} }-3$

\
$\mu$ = Rerata\
$\sigma$ = Standar Deviasi\
$\theta$ = Skewness\
$\gamma$ = Kurtosis\
$M$ = Panjang Citra\
$N$ = Lebar Citra
"""

def img_stat(img, digit):
    rgb = img[:,:,::-1].copy().astype(float)
    r = rgb[:,:,0]
    g = rgb[:,:,1]
    b = rgb[:,:,2]

    jumlah = rgb.shape[0]*rgb.shape[1]

    mean_r = np.sum(r)/(jumlah)
    mean_g = np.sum(g)/(jumlah)
    mean_b = np.sum(b)/(jumlah)

    dev_r = np.sqrt(np.sum((r-mean_r)**2)/(jumlah))
    dev_g = np.sqrt(np.sum((g-mean_g)**2)/(jumlah))
    dev_b = np.sqrt(np.sum((b-mean_b)**2)/(jumlah))

    skew_r = np.sum((r-mean_r)**3)/(jumlah*(dev_r**3))
    skew_g = np.sum((g-mean_g)**3)/(jumlah*(dev_g**3))
    skew_b = np.sum((b-mean_b)**3)/(jumlah*(dev_b**3))

    cur_r = np.sum((r-mean_r)**4)/(jumlah*(dev_r**4))-3
    cur_g = np.sum((g-mean_g)**4)/(jumlah*(dev_g**4))-3
    cur_b = np.sum((b-mean_b)**4)/(jumlah*(dev_b**4))-3

    return (round(mean_r, digit),
            round(mean_g, digit), 
            round(mean_b, digit), 
            
            round(dev_r, digit),
            round(dev_g, digit),
            round(dev_b, digit),
            
            round(skew_r, digit),
            round(skew_g, digit),
            round(skew_b, digit),
            
            round(cur_r, digit),
            round(cur_g, digit),
            round(cur_b, digit))

mean_r, mean_g, mean_b, dev_r, dev_g, dev_b, skew_r, skew_g, skew_b, cur_r, cur_g, cur_b = img_stat(img, 5)

stat = f"""mean_r: {mean_r}
mean_g: {mean_g}
mean_b: {mean_b}

dev_r: {dev_r}
dev_g: {dev_g}
dev_b: {dev_b}

skew_r: {skew_r}
skew_g: {skew_g}
skew_b: {skew_b}

cur_r: {cur_r}
cur_g: {cur_g}
cur_b: {cur_b}
"""

print(stat)

with open(os.path.join(pc_folder, "stat_warna.txt"), 'w') as f:
    f.write(stat)



"""## **Brightness & Contrast**

**Mengaplikasikan Kontras:**\
$C = \begin{matrix}
(img/255 \times Kontras) \times 255 & ,[0,255)
\end{matrix}$

$B = \begin{matrix}
img + Kecerahan& ,[0,255)
\end{matrix}$

\
$C$ = Citra Kontras\
$K$ = Citra Kecerahan\
$img$ = Array Citra
"""

def apply_brightness_and_contrast(img,brightness,contrast):
    img_cont = np.clip(img/255 * contrast,0,1)*255
    img_bright = np.clip(((img_cont).astype(float)+brightness),0,255)

    img_bright_cont = img_bright.astype(np.uint8)

    return img_bright_cont

contrast = 0.4 #@param {type: "slider", min: 0, max: 15 ,step: 0.1}
brightness = 36 #@param {type: "slider", min: -255, max: 255}

img_brightness_and_contrast =  apply_brightness_and_contrast(img, brightness, contrast)

cv2.imwrite(os.path.join(pc_folder, f"img_brightness_{brightness}_contrast_{contrast}.jpg"), img_brightness_and_contrast)
show_image(img_brightness_and_contrast)



"""## **Jumlah Warna**

Algoritma menghitung jumlah warna:
- Mengubah array citra menjadi satu baris
- Mengurutkan dan membuang piksel duplikat
- Menghitung jumlah piksel unik
"""

def jumlah_warna(img):
    pix = img[:,:,::-1].copy()
    jumlah_pixel = pix.shape[0]*pix.shape[1]

    pix_list = pix.reshape((jumlah_pixel,3))
    unique_pix_list = np.unique(pix_list, axis=0)

    jumlah = len(unique_pix_list)

    return jumlah, unique_pix_list

def unique_warna_img(jumlah_warna_img, unique_warna_list):
    factor = []
    for i in range(1, int(np.sqrt(jumlah_warna_img))+1):
        if jumlah_warna_img % i == 0:
            factor.append((i, int(jumlah_warna_img/i)))

    row, col = factor[-1]
    unique_img_color = Image.fromarray(unique_warna_list.reshape(row,col,3))
    print(jumlah_warna_img)

    return unique_img_color

jumlah_warna_img, unique_warna_list = jumlah_warna(img)

warna = unique_warna_img(jumlah_warna_img, unique_warna_list)
warna.save(os.path.join(pc_folder, f"img_warna_gambar_{jumlah_warna_img}.jpg"))
warna



"""## **Aplikasi Pencarian Citra Berdasarkan Warna Dominan**

Algoritma dari aplikasi ini berasal dari flowchart yang ada pada pdf elena

![2021-05-16 09_47_48-PC Berwarna.pdf and 6 more pages - Profile 1 - Microsoft‚Äã Edge.png](https://drive.google.com/uc?export=view&id=13sHHCLKat37MPtQbDgxMMv8P0PteGwYe)

pertama kita membuat citra biner yang menunjukan warna yang sesuai dengan jangkauan sebagai piksel putih dan warna lain sebagai piksel hitam

berikut contoh citra biner img ketika difilter menggunakan jangkauan warna cyan
"""

img_hsv = RGB2HSV(img)
img_hsv[:,:,0] = np.around(img_hsv[:,:,0]/255*180)

lower_cyan = (74,25,38)
upper_cyan = (109, 255, 255)
mask_cyan = cv2.inRange(img_hsv, lower_cyan, upper_cyan)
show_image(img)
show_image(mask_cyan)
# show_image(cv2.bitwise_and(img, img, mask=mask_cyan))

"""kemudian kita mencari jangkauan untuk semua warna dengan menggunakan diagram dari pdf elena dan trial and error menggunakan color picker: https://alloyui.com/examples/color-picker/hsv.html

![](https://drive.google.com/uc?export=view&id=1fOmLhTc9JSiaem93eKlEOdVtSfYW9fY6)
"""

img_list = {"img_lights.jpg" : "https://www.w3schools.com/w3css/img_lights.jpg",
            "matrix-coded-bitstreams-green-background_257312-378.jpg" : "https://img.freepik.com/free-vector/matrix-coded-bitstreams-green-background_257312-378.jpg?size=338&ext=jpg",
            "c830fcc.jpg" : "https://thumbnails.yayimages.com/1600/c/830/c830fcc.jpg",
            "P3160036.jpg" : "https://www.onfocus.com/cam/2003/sunday/P3160036.jpg",
            "51zVBoUFIBL._AC_.jpg" : "https://images-na.ssl-images-amazon.com/images/I/51zVBoUFIBL._AC_.jpg",
            "01_3.12.11-14_resize.jpg" : "https://www.pentaxforums.com/content/uploads/files/77/p2299/01_3.12.11-14_resize.jpg",
            "yellow-plants-leaf-nature-wallpaper-thumb.jpg" : "https://c1.peakpx.com/wallpaper/528/876/1016/yellow-plants-leaf-nature-wallpaper-thumb.jpg",
            "4JGtFkT.jpg" : "https://i.imgur.com/4JGtFkT.jpg",
            "architecture-building-cathedral-church-thumb.jpg":"https://i1.pickpik.com/photos/69/872/890/architecture-building-cathedral-church-thumb.jpg",
            "cloud.jpg":"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQIyx-nC4_hVgbj_NAoF3UcpfnbazRb1cQbwgQzp2zncgBBVWDd8K6u4qx0_N691oU_wFc&usqp=CAU",
            "blue.jpg":"https://qph.fs.quoracdn.net/main-qimg-148273c77220a673101cdbac9c9092a4",
            "carnavale.jpg":"http://thedreamwithinpictures.com/wp-content/uploads/2015/05/42e9d__colour.jpg",
            "bougainvillea-flowers-purple-violet-wallpaper-thumb.jpg":"https://c2.peakpx.com/wallpaper/607/279/735/bougainvillea-flowers-purple-violet-wallpaper-thumb.jpg",
            "6406348_preview.png":"https://i.dlpng.com/static/png/6406348_preview.png",
            "magenta.jpg":"https://plchldr.co/i/250x215?&bg=ff28ff&text=",
            "pink wallpaper.jpg":"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQqzbOO5ff5oqUzo5oVtwbGIR1KYpNq-8aClA&usqp=CAU",
            "440px-Wildlife-kingparrot-female-1.png":"https://upload.wikimedia.org/wikipedia/commons/thumb/c/ca/Wildlife-kingparrot-female-1.png/440px-Wildlife-kingparrot-female-1.png",
            "bdf011bc808f1db81aa71bf171e42fbf.jpg":"https://i.pinimg.com/736x/bd/f0/11/bdf011bc808f1db81aa71bf171e42fbf.jpg",
            "10719136_97a287bf-4a8d-4345-be41-3c79b10c2c71.jpg":"https://www.artmajeur.com/medias/standard/d/a/daria-ladnyuk/artwork/10719136_97a287bf-4a8d-4345-be41-3c79b10c2c71.jpg",
            "256x256x1.jpg":"https://assets.community.lomography.com/ce/f2a4f2fcb8ac0fe8ee276b1898d21b9d16e91f/256x256x1.jpg?auth=3a7c3d8df90aee39f23609cc61aac2bc63da7fe4",
            }

test_image_folder = os.path.join(pc_folder, "test_image")
if not os.path.exists(test_image_folder):
  os.makedirs(test_image_folder)

test_image_folder

for i in img_list.items():
    test_img = url_to_image(i[1])
    cv2.imwrite(os.path.join(test_image_folder, i[0]), test_img)

colorpick = drive_to_image("1O_dGo_9aRixY-1lTaBzppkeuOCInUM9A")
show_image(colorpick, figsize=(30,20))

colorpick_hsv = cv2.cvtColor(colorpick, cv2.COLOR_BGR2HSV)

lower_red1 = (0, 25, 38)
upper_red1 = (15, 255, 255)

lower_red2 = (165, 25, 38)
upper_red2 = (180, 255, 255)

mask_red1 = cv2.inRange(colorpick_hsv, lower_red1, upper_red1)
mask_red2 = cv2.inRange(colorpick_hsv, lower_red2, upper_red2)
mask_red = mask_red1 + mask_red2
show_image(cv2.bitwise_and(colorpick, colorpick, mask=mask_red))

lower_orange = (0,25,38)
upper_orange = (30, 255, 255)
mask_orange = cv2.inRange(colorpick_hsv, lower_orange, upper_orange)
show_image(cv2.bitwise_and(colorpick, colorpick, mask=mask_orange))

lower_yellow = (15,25,38)
upper_yellow = (39, 255, 255)
mask_yellow = cv2.inRange(colorpick_hsv, lower_yellow, upper_yellow)
show_image(cv2.bitwise_and(colorpick, colorpick, mask=mask_yellow))

lower_green = (35,25,38)
upper_green = (74, 255, 255)
mask_green = cv2.inRange(colorpick_hsv, lower_green, upper_green)
show_image(cv2.bitwise_and(colorpick, colorpick, mask=mask_green))

lower_cyan = (74,25,38)
upper_cyan = (109, 255, 255)
mask_cyan = cv2.inRange(colorpick_hsv, lower_cyan, upper_cyan)
show_image(cv2.bitwise_and(colorpick, colorpick, mask=mask_cyan))

lower_blue = (90,25,38)
upper_blue = (135, 255, 255)
mask_blue = cv2.inRange(colorpick_hsv, lower_blue, upper_blue)
show_image(cv2.bitwise_and(colorpick, colorpick, mask=mask_blue))

lower_purple = (127,25,38)
upper_purple = (150, 255, 255)
mask_purple = cv2.inRange(colorpick_hsv, lower_purple, upper_purple)
show_image(cv2.bitwise_and(colorpick, colorpick, mask=mask_purple))

lower_magenta = (135,25,38)
upper_magenta = (165, 255, 255)
mask_magenta = cv2.inRange(colorpick_hsv, lower_magenta, upper_magenta)
show_image(cv2.bitwise_and(colorpick, colorpick, mask=mask_magenta))

lower_pink = (150,25,38)
upper_pink = (180, 255, 255)
mask_pink = cv2.inRange(colorpick_hsv, lower_pink, upper_pink)
show_image(cv2.bitwise_and(colorpick, colorpick, mask=mask_pink))

lower_white = (0,0,230)
upper_white = (180, 50, 255)
mask_white = cv2.inRange(colorpick_hsv, lower_white, upper_white)
show_image(cv2.bitwise_and(colorpick, colorpick, mask=mask_white))

lower_gray = (0,0,10)
upper_gray = (180, 0, 220)
mask_gray = cv2.inRange(colorpick_hsv, lower_gray, upper_gray)
show_image(cv2.bitwise_and(colorpick, colorpick, mask=mask_gray))

lower_black = (0,0,0)
upper_black = (180, 255, 16)
mask_black = cv2.inRange(colorpick_hsv, lower_black, upper_black)
show_image(cv2.bitwise_and(colorpick, colorpick, mask=mask_black))



def dominant_color(img):
    RGB = img.copy()
    HSV = RGB2HSV(RGB)
    HSV[:,:,0] = np.around(HSV[:,:,0]/255*180)

    jumlah_pix_warna = dict()

    #range merah
    lower_red1 = (0, 25, 38)
    upper_red1 = (15, 255, 255)

    lower_red2 = (165, 25, 38)
    upper_red2 = (180, 255, 255)

    mask_red1 = cv2.inRange(HSV, lower_red1, upper_red1)
    mask_red2 = cv2.inRange(HSV, lower_red2, upper_red2)
    mask = mask_red1 + mask_red2
    jumlah_pix_warna["merah"] = int(np.sum(mask/255))

    #range orange
    lower_orange = (0,25,38)
    upper_orange = (30, 255, 255)
    mask = cv2.inRange(HSV, lower_orange, upper_orange)
    jumlah_pix_warna["jingga"] = int(np.sum(mask/255))

    #range kuning
    lower_yellow = (15,25,38)
    upper_yellow = (39, 255, 255)
    mask = cv2.inRange(HSV, lower_yellow, upper_yellow)
    jumlah_pix_warna["kuning"] = int(np.sum(mask/255))

    #range hijau
    lower_green = (35,25,38)
    upper_green = (74, 255, 255)
    mask = cv2.inRange(HSV, lower_green, upper_green)
    jumlah_pix_warna["hijau"] = int(np.sum(mask/255))

    #range cyan
    lower_cyan = (74,25,38)
    upper_cyan = (109, 255, 255)
    mask = cv2.inRange(HSV, lower_cyan, upper_cyan)
    jumlah_pix_warna["cyan"] = int(np.sum(mask/255))

    #range biru
    lower_blue = (90,25,38)
    upper_blue = (135, 255, 255)
    mask = cv2.inRange(HSV, lower_blue, upper_blue)
    jumlah_pix_warna["biru"] = int(np.sum(mask/255))

    #range ungu
    lower_purple = (127,25,38)
    upper_purple = (150, 255, 255)
    mask = cv2.inRange(HSV, lower_purple, upper_purple)
    jumlah_pix_warna["ungu"] = int(np.sum(mask/255))

    #range magenta
    lower_magenta = (135,25,38)
    upper_magenta = (165, 255, 255)
    mask = cv2.inRange(HSV, lower_magenta, upper_magenta)
    jumlah_pix_warna["magenta"] = int(np.sum(mask/255))

    #range pink
    lower_pink = (150,25,38)
    upper_pink = (180, 255, 255)
    mask = cv2.inRange(HSV, lower_pink, upper_pink)
    jumlah_pix_warna["pink"] = int(np.sum(mask/255))

    #range putih
    lower_white = (0,0,220)
    upper_white = (180, 50, 255)
    mask = cv2.inRange(HSV, lower_white, upper_white)
    jumlah_pix_warna["putih"] = int(np.sum(mask/255))

    #range gray
    lower_gray = (0,0,10)
    upper_gray = (180, 0, 220)
    mask = cv2.inRange(HSV, lower_gray, upper_gray)
    jumlah_pix_warna["abu-abu"] = int(np.sum(mask/255))

    #range hitam
    lower_black = (0,0,0)
    upper_black = (180, 255, 16)
    mask = cv2.inRange(HSV, lower_black, upper_black)
    jumlah_pix_warna["hitam"] = int(np.sum(mask/255))
    
    return max(jumlah_pix_warna, key=jumlah_pix_warna.get)

dominant_color(img)

def cariwarna(warna, direktori):
    hasil = dict()
    for i in os.listdir(direktori):
        image_path = os.path.join(direktori, i)
        image = cv2.imread(image_path)
        if dominant_color(image) == warna:
            hasil[i] = image_path
    
    jumlah_hasil = len(hasil)

    if jumlah_hasil == 0:
        return None

    factor = []
    for i in range(1, int(np.sqrt(jumlah_hasil))+1):
        if jumlah_hasil % i == 0:
            factor.append((i, int(jumlah_hasil/i)))
    
    row, col = factor[-1]
    plt.figure(figsize = (10,5))
    plt.suptitle(warna, fontsize=20, y=1.08)
    for num, i in enumerate(hasil.items()):
        image = Image.open(i[1])
        plt.subplot(row,col,num+1)
        plt.tight_layout()
        plt.title(i[0])
        plt.axis('off')
        plt.imshow(image)
    
    return hasil

finded = cariwarna("cyan", test_image_folder)

warna_list = ["merah", "jingga", "kuning",
              "hijau", "cyan", "biru",
              "ungu", "magenta", "pink",
              "putih", "abu-abu", "hitam"]

for i in warna_list:
    cariwarna(i, test_image_folder)

